{\rtf1\ansi\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Courier New;}}
{\colortbl ;\red255\green255\blue0;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\f0\fs22\lang1033 Tile Map Accelerator 1.3\par
by Revision3\par
\par
# Introduction\par
\par
Tile Map Accelerator is an all in one solution for fully GPU based tile map rendering, \par
allowing for massive render distances and seamless camera zooming over tiled maps.\par
\par
This asset contains the main Shader used to render maps, as well as all the scripts needed to\par
load, generate, interact with or edit tile maps at runtime, in 2D mode. \par
\par
It can also be used in 3D mode to very efficiently render all sorts of tiled content, \par
such as procedural TV white noise, minimaps, game of life simulations, LED dot matrices, and much more!\par
\par
# Getting Started\par
\par
To quickly get started testing the asset :\par
\par
1. Load the "QualitySettings" preset file located inside the Demo Scene folder. ( Edit > Project Settings > Quality > Select Preset )\par
2. Load one of the various scene files located inside the Demo Scene folder. Newest Demo Is "isometricdemov2" ( or "isometricdemov2 NVIDIA" for Nvidia Hardware Having Issues With Other Scene )\par
3. Hit Play!\par
\par
Once inside play mode, the controls are as follows for non isometric demo scenes : \par
\par
W A S D\tab\tab : Move Camera ( When not focused on player obj )\par
- AND =\tab\tab : Zoom Camera\par
Left Click\tab : Select tile\par
F\tab\tab\tab : Toggle Player Focus / Camera Lock\par
Arrow Keys\tab : Move Player Object ( Use Space To Jump in "Platformer" Style Demo Scene )\par
E\tab\tab\tab : Enter Edit Mode\par
\par
While in Edit Mode :\par
\par
1\tab\tab\tab : Select Grass01 Tile At Selected Tile Position\par
2\tab\tab\tab : Select Tree01 Tile At Selected Tile Position\par
3\tab\tab\tab : Select Tree02 Tile At Selected Tile Position\par
0\tab\tab\tab : Select Water Tile At Selected Tile Position\par
ENTER\tab\tab : Bake active changes to GPU map\par
\par
For the isometric demo scenes : \par
\par
LEFT CLICK\tab\tab\tab : Select Tile ( Make Edit While In Edit Mode )\par
RIGHT CLICK + DRAG\tab : Move camera\par
SCROLL WHEEL\tab\tab : Zoom Camera\par
- AND =\tab\tab\tab\tab : Zoom Camera ( Alternate Controls )\par
F\tab\tab\tab\tab\tab : Toggle Selector Z position ( To preview Pseudo 3D effect )\par
G\tab\tab\tab\tab\tab : Generate New Map\par
S\tab\tab\tab\tab\tab : Save Generated Map To Set Path\par
L\tab\tab\tab\tab\tab : Load Map File From Set Path\par
E\tab\tab\tab\tab\tab : Open Edit Mode GUI ( Only for V2 scene )\par
\par
Note that changing the set map size and nosie map resolution in square demo scenes may spawn the player object in water, restricting movement. \par
If this happens, simply move the player on grass, copy the transform, exit play mode, paste the values and save the scene.\par
By entering play mode again the player should now be on grass and able to move around using the arrow keys.\par
\par
For isometric demo scene map sizes should follow the rule that width is equal to 1/2 height + 4. \par
When using Nvidia compatibility it should be equal to 1/2 height, and both values must be power of two.\par
\par
# Usage Information\par
\par
Here is a detailed usage explanation of the various components offered with this asset.\par
\par
- TileMapManager.cs\par
\par
\tab This script is the main tile map management script responsible for taking tile map data and feeding it to the Shader.\par
\par
\tab\highlight1 Attach to a plane object using the included MapMat material to render on the plane.\highlight0\par
\par
\tab\highlight1 The "TextureSize" field represents the size of your tile sprites. For the demo scene, this is 128 since the included tiles are 128x128.\highlight0\par
\tab\par
\tab "Auto Tile Grass Prefix" is a field used to demonstrate the AutoTiling abilities of the asset. This prefix is used to find the Grass AutoTileset in Resources.\par
\par
\tab\highlight1 The most important part of this script is the tileTypeArray data array. This variable contains the main tile map data sent to the shader.\highlight0\par
\tab Currently this data array is being filled with a simplex noise map generator module, but it can be filled by any function or class.\par
\tab It could be used to contain other types of procedurally generated maps or even load data from a drive to display as a tile map.\par
\par
\tab See the Start() function for a full example on how to prepare the TileMapManager for tile map rendering.\par
\par
\tab Added in 1.2, the "Tile Type Library Path" parameter can be used to point to other tile type libraries. Like sprites, the root path for fetching is "Resources/"\par
\par
- SimplexMapGenerator.cs, BigIslandMapGenerator.cs & ITileMap.cs interface\par
\par
\tab SimplexNoiseMapGenerator.cs is the main tile map generation module, responsible for the creation of a simplex noise map to render as an example.\par
\par
    \highlight1 The "MapSize" field represents the total size of the Tile Map being generated. To speed up map edit baking, use small sized maps.\par
\highlight0\par
\tab Using regular chunking techniques, map edit baking can become essentially seamless, if you plan to use this for a game where lots of edits will be made in a \par
\tab short amount of time. Map Sizes of 128 to 512 should, on most modern hardware, be updated and sent to the GPU every second while maintaining FPS above 120.\par
\tab For smooth animated content and game of life simulations, it is recommended to use a map size of 128 to 256.\par
\tab The Demo scene uses a map size of 2048 to demonstrate the seamless camera zoom and movement ability, but it takes about a second to bake new changes.\par
\par
\tab If your intent is to simply render huge maps, this size can go much higher. I successfully tested up to 8192x8129.\par
\tab The map may take longer to load but once loaded the performance will be as good as it would be on any other sized map. \par
\par
\tab\highlight1 In short the only performance bottleneck when it comes to huge map size has to do with editing the map, not rendering it.\highlight0\par
\par
\tab The "Noise Resolution" field represents the sampling resolution of the simplex noise algorithm. \par
\tab Playing with this setting will create more / smaller islands or fewer / bigger continents.\par
\par
\tab Currently, this script is responsible for generating a tile map using simplex noise. \par
\tab\highlight1 This could be replaced with another that loads a file from your hard drive to use as a map. It could be changed to another procedural generator.\highlight0\par
\tab It could load in a string and use custom code do display a simulated LED dot matrix text banner. It could also just display an image file.\par
\tab This function has absolutely no ties to the Unity Engine. It can therefore be safely multithreaded to speed up your generation times.\par
\par
\highlight1\tab If you want to create a custom tile map generation class and have more complex tile map generation code, the class must implement the ITileMap.cs interface.\par
\par
\tab This interface contains three methods to implement : GetData(), GetMapInfo() and Generate().\par
\par
\tab GetData() must return a 2D unsigned integer array, representing the array of unique tile types making up your tile map.\par
\tab\par
\tab GetMapInfo() must return a TileMapInfo struct containing tile map information like size and init state.\par
\par
\tab Finally, Generate() is a simple link to whichever method initiates the tile map generation in your map generator class. \par
\tab It does not return anything and can contain calls to multiple other functions. \par
\highlight0\tab\highlight1 The main requirement is that this function fills the data array returned with the GetData() function.\highlight0\par
\par
\tab BigIslandMapGenerator.cs is another style of simplex map generation, creating a giant island with water around it.\par
\tab It's usage is very similar to the main map generation module. You can use the "BigIslandDemoScene" scene to try it out.\par
\par
- AnimationController.cs\par
\par
\tab Added in 1.1, this feature allows for simple map wide animations. The feature is limited by a few factors :\par
\tab\tab\par
\tab\tab 1 - All animations must be contained within a single "timeline". \par
\tab\tab 2 - All animations must work with the same loop style ( Regular Loop , Back and Forth )\par
\tab\tab 3 - Animations that are shorter than the full size of the timeline should loop correctly ( Need right amount of animation frames )\par
\par
\tab Sadly, the script currently does not feature an easy made GUI to create animations. \par
\tab For the moment, animations frames are stored as extra tile type sprites in resources.\par
\par
\tab The script then contains a few parameters to control animations. \par
\par
\tab First is the "Framerate" which controls the speed of the map wide animation system.\par
\par
\tab Next is the "Loop Style" which controls type of loop used by the animation system.\par
\tab\tab\par
\tab\tab - Loop : Regular loop. Once the last frame has been reached, start back at frame 0.\par
\tab\tab - Back And Forth : Alternating Loop. Start at frame 0 moving forward. Once the last frame has been reached, move backwards to frame 0. So on and so forth. \par
\tab\par
\tab Finally, the "Frame Types" array contains the actual "Frames" of animation. Here is how the system works.\par
\par
\tab Each line of the array is a line of text representing single animation frame. Format is [number][comma][number][comma] etc... \par
\tab\par
\tab Numbers are the sprite used for each tile types which represented by the order of the numbers. First number is sprite used for Tile Type 0 at this particular animation frame.\par
\par
\tab For example, this system automatically creates the Animation Frame #0 using your base tile map. It would be : 0,1,2,3,4,5,6,7,8... because regular sprites are used.\par
\par
\tab In the animated demo scene example, the animation frames for the grass tile of value 5 have been set as tile types 53 and 54.\par
\par
\tab Therefore, the animation frames in this demo scene are like this : \par
\par
\tab\tab - 0,1,2,3,4,53,6,7,8,9,10,11,12,13...\par
\tab\tab - 0,1,2,3,4,54,6,7,8,9,10,11,12,13...\par
\par
\tab Using the back and forth loop type this creates a full animation loop of 4 frames. \par
\par
\tab Again, this system is suited for very simple very short map wide background animation loops. \par
\tab For anything more complex just use native unity animation system and sprites.\par
\par
\tab NOTE : This system is a WIP with a relatively messy interface. The animation system will be improved with a custom GUI in a future version.\par
\par
- TileMapInteraction.cs\par
\par
\tab This script contains the interaction featureset used to allow mouse selection of map tiles and colision detection for the player object.\par
\tab When attached to a plane object containing TileMapManager, this script gathers information about the tile map, such as world size of a single tile.\par
\par
\tab The "Cam" , "Camera Speed" and "Camera Focused Zoom" parameters are used to link a camera object, scale it's movement speed and set the player focus zoom value. \par
\par
\tab "Selected Tile" is a debug Vector2 field showing the currently selected tile. While playing, you can observe this parameter changing as you click on map tiles.\par
\par
\tab Finally, "Player Obj" is the transform link to our player object, being controlled with arrow keys. The demo scene player obj uses a basic top down controller.\par
\par
\tab Make sure to scale your player object accordingly. Making a bigger map on a same sized plane will inherently create smaller tiles, so other scene objects must be scaled.\par
\tab You may experience colision detection issues at very small scales. To solve this, simply scale up the main plane object. You may also need to fix speed and zoom values.\par
\tab\par
- TopDownPlayerController.cs\par
\par
\tab Related to the TileMapInteraction.cs script. Uses a rigidbody and collider to add forces to a 2D sprite and provide colision detection.\par
\par
\tab The only parameter is "Move Speed", which scales the speed at which the player object moves.\par
\par
- ActiveLayerManager.cs\par
\par
\tab This is the map edition module for the asset, used to place basic sprites gameobjects on top of the current world and then bake edits to the world.\par
\tab Since baking a tile map to a GPU texture may take a long time, active tiles are a perfect solution to store and render a reasonable amount of edits.\par
\tab\par
\tab "Active Layer Z Pos" is the position of the active layer object spawn point on the Z axis.\par
\par
\tab The next object slots are used to link the various sprite objects. They are created in advance as simple gameobjects and instantiated where needed.\par
\tab Once again, bigger maps mean smaller tile size. Make sure you scale the active tile gameobjects accordingly when changing map size.\par
\par
\tab AutoTiles and new collider states will only be applied upon the map being baked.\par
\par
- AutoTileUtilities.cs & AutoTileGUI.cs\par
\par
\tab This is the AutoTile module for the asset. The Utilities script contains various helper functions used to calculate autotiles.\par
\par
\tab The GUI, which can be found under "Window > Tile Map Accelerator > AutoTileset Generator", is used to generate tilesets from AutoTile atlases.\par
\par
\tab The full 46 variations, excluding a full tile, will be automatically generated from a source atlas. The Tile Size can be manually set.\par
\par
\tab The GUI can generate this tileset to an external folder or also directly to the Resources folder of the asset. A file prefix can also be used.\par
\par
- [UPDATED] TileType.cs & TileTypeManagerGUI.cs\par
\par
\tab Tile Types are an integral part of this asset. The data structure is used to convert from UINT to a COLOR32 value and vice versa.\par
\tab According to the official documentation of the HLSL shader language, the maximum amount of elements for a Texture2DArray is 2048.\par
\tab This means that values beyond 2048 will not count as unique tile types. However, the remaining space can be used for another array.\par
\tab For instance, the first 2048 types could be used for base background types, while the next 2048 could contain decorative sprites.\par
\tab The shader could then merge both textures together and create the final rendered tile. This feature may be added in a future version.\par
\par
\tab The GUI can be used to create and manage your "Manual" tile types. Each type has a base UINT value, a name and a sprite path.\par
\tab The UINT value is the important unique identifier for this type. Name is optional, but may be used to help identify types in script.\par
\tab The sprite path is rooted to "Resources". A sprite located at "Resources/MySprites/Sprite01.png" is refered to with "MySprites/Sprites01"\par
\tab\par
\tab While using a Name for tile types is a way to help identify them in scripts, if you are going to be making lots of references to tile types\par
\tab it is recommended to simply store the UINT value of the needed types as a bunch of constant globals. That way the code does not have\par
\tab to do costly String equivalency testing before knowing which tile types are being delt with.\par
\par
\tab Finally, AutoTile types use an automated system to generate tile types automatically for each piece of the AutoTileset.\par
\tab A AT_START value, representing the start of an AutoTile type region, is defined as a constant UINT global in the TileType script.\par
\tab Starting from this value, the TileMapManager.cs script will generate the types needed for each AutoTile.\par
\par
\tab Two important functions within the TileType.cs script are HasCollider() and InitColliderSpecLibrary().\par
\tab The first one will return true or false depending on if the input tile type has a collider.\par
\tab The second one is used to initialize collider specifications for each type that has a collider.\par
\tab Refer to existing examples to build upon these functions and add collders to your own tile types.\par
\tab More complex collision shapes could be made using polygon and composite colliders. This may be added in a future version.\par
\par
\tab Added in 1.3, the ISO HEIGHT value of a tile type can be used to define isometric objects that span more than 1 view tile vertically ( the "ground" tile ).\par
\tab An isometric cube would have a iso height of 1. Two of these stacked would have a iso height of 2. This value is always an integer.\par
\tab When this value is higher than 0, the sprite path string must point to a folder and end with a '/' rather than a file. ( EX : MyTileSet/SomeIsoObject/ )\par
\tab This folder must contain sprites generated using the Isometric Tile Splitter GUI. Sprites will be fetched using the automated naming scheme.\par
\par
- TriggerEventController.cs\par
\par
\tab A simple script to execute a delegate function upon this object being triggered. Not much to edit here. \par
\tab Could still be edited to do different things depending on amount of colliders in range, if desired.\par
\par
- FastMapShader.shader\par
\par
\tab This is the core shader script used to take in a Texture2DArray of tiles and combine it to a Tile Map sent as a Texture2D to render tile maps.\par
\tab The shader is extremely fast for rendering and allows for seamless zooming in and out on utterly huge tile maps, up to 16384x16384 per Texture2D.\par
\tab Using multiple materials and a bit of custom chunking, it would be possible to go even bigger with stellar performance.\par
\tab This may be a feature added to the asset in a future release.\par
\par
\tab As mentioned in the asset description as an important notice, due to relying on the Texture2DArray function this shader will not work on all hardware. \par
\tab\par
\tab Here is a partial list of compatible hardware / graphics libraries : \par
\par
\tab - Direct3D 11/12 (Windows, Xbox One)\par
\tab - OpenGL Core (Mac OS X, Linux)\par
\tab - Metal (iOS, Mac OS X)\par
\tab - OpenGL ES 3.0 (Android, iOS, WebGL 2.0)\par
\tab - PlayStation 4\par
\par
\tab To ensure a certain platform is compatible with this function, Unity provides the SystemInfo.supports2DArrayTextures readonly boolean.\par
\par
\tab The shader could be adapted to work on older hardware using a simple texture atlas generator to send sprites to the shader \par
\tab as a single textureinstead of using Texture2DArray. This may be added in a future version of the asset as an alternate shader file.\par
\par
\tab In version 1.1, a transparency enabled shader variant was added to the asset. It can be used to allow multi layering and semi/fully transparency in sprites.\par
\par
- AutoChunkManager.cs & ShaderLink.cs\par
\par
\tab Added in 1.1, AutoChunkManager.cs is used for management of "Auto Chunking", a feature allowing for the shader based tile map to be subdivided into multiple meshes.\par
\tab This features allows for faster edit baking, as the time it takes to send a Texture2D to the GPU is directly tied to it's size.\par
\tab All in all, the main map manager script is still active and in use, but the renderer component can be turned off to gain a bit of performance.\par
\tab Interactions and collisions will still happen on the full sized map, for added ease of use, but the rendering will be split between many meshes.\par
\par
\tab Since the script requires fewer management functions, the ShaderLink.cs script is used to provide the minimum access required \par
\tab to change the tile map and tile set of a particular mesh using the tile map shader.\par
\par
\tab AutoChunkManager contains a few parameters : \par
\tab\tab\par
\tab\tab - Chunk Amount : Amount of chunks generated by the script. Value is used to subdivide X and Y axis, so a value of 3 would create 9 chunks, 2 would create 4.\par
\tab\tab - Main Chunk : A sample game object that must be of same size as the main chunk manager. It must usd the ShaderLink.cs component and a mesh renderer using the shader.\par
\par
\tab To set up the main chunk, simply duplicate the main map renderer object and remove all of the custom script components. Leave the mesh filter, renderer and collider.\par
\tab Then, simply add the ShaderLink.cs component to this object and finally link it as the Main Chunk on the main map renderer object's TileMapManager.cs component.\par
\par
\tab The ShaderLink.cs utility can also be used alone by users who do not want to use any of the included map management and generation scripts. \par
\tab It contains two functions : SendMap() used to send a uint[,] array to the shader as a texture to update the "map" data and SendTileSet() to update the tile set sprites.\par
\tab These two functions also describe how the shader interactions happen, by accessing the material properties _TileMap, _TileMapSize and _TileSetArray.\par
\par
- MultiLayerManager.cs & MultiLayerMapGenerator.cs\par
\par
\tab Added in 1.1, this manager script allows for multi layered tile maps to be generated, rendered by the shader and interacted with.\par
\tab Since this feature requires extra tile map data arrays to store the extra layers, only use this feature with medium to small map sizes.\par
\tab The demo scene uses 3 layers of 1024 x 1024 tile maps. While performance may not be affected by bigger maps, RAM & VRAM usage will increase no matter what.\par
\par
\tab Currently, Tile Map Edits are only baked for the background layer. A future update will include the multi layer live edits feature.\par
\tab Animation is currently unsupported out of the box for multi layered maps. This will be added in a future update.\par
\par
\tab The Multi Layer Manager contains the following parameters : \par
\par
\tab\tab - Layers\tab\tab  :\tab An array of Game Object slots where you must link the various layers. \par
\tab\tab\tab\tab\tab\tab\tab The background layer can use Tile Map Manager, Interaction and Active Layer Manager components.\par
\tab\tab\tab\tab\tab\tab\tab Extra layers should only contain the Tile Map Manager & Interaction components.\par
\par
\tab\tab - Set Draw Layer :\tab The selected layer to draw. Value usage depends on Render Mode.\par
\par
\tab\tab - Render Mode\tab  :\tab How layers will be drawn using the selected layer value. Available Modes : \par
\par
\tab\tab\tab\tab\tab\tab\tab - All\tab\tab  : Draws all layers regardless of selected layer.\par
\tab\tab\tab\tab\tab\tab\tab - From Set   : Draws selected layer and any layer after it.\par
\tab\tab\tab\tab\tab\tab\tab - To Set\tab  : Draws selected layer and any layer before it.\par
\tab\tab\tab\tab\tab\tab\tab - Before Set : Draws any layer before the selected layer.\par
\tab\tab\tab\tab\tab\tab\tab - After Set  : Draws any layer after the selected layer.\par
\tab\tab\tab\tab\tab\tab\tab - Set Only\tab  : Draws the selected layer exclusively.\par
\tab\tab\tab\tab\tab\tab\tab - None\tab\tab  : Draws nothing.\par
\par
\tab The multi layer map generator script is a simple variant of the simplex map generator that allows the handling of extra layers.\par
\tab This pairs with the new TileTemplateManager.cs script, which allows "stamping" of multi tile templates made of modular sprites.\par
\tab Templates that have been created to have more than one layer must be used with a generator that has at least that amount of layers.\par
\par
\tab The Map Generator features a few similar parameters to the other map generators such as Size and Noise Resolution ( Res ).\par
\tab\par
\tab The "Layers" parameter must be set to the same amount of layers you are using with the multi layer manager.\par
\tab Currently, non background layers are initialized with the TRANSPARENT tile type.\par
\par
\tab "Template Library Paths" is an array of strings used to reference Template files in Resources for use with the generator.\par
\tab To not use file extension or the "Resources/" prefix when listing template files. Refer to the multi layer demo scene for examples.\par
\par
\tab "Templates To Add" is the amount of templates the generator will attempt to add to the tile map overall. \par
\tab This value may or may not be reached depending on the "Max Template Attempts" value, which controls how many random positions are tested.\par
\par
\tab Since 1.2, it is also possible to set the Tile Type Library Path for multi layered maps. Fetching is the same as the TileMapManager path field.\par
\tab The main difference here is that whatever paths are set on the various manager object components will be overridden by this value upon init.\par
\par
- TemplateEditor.cs & TileTemplateManager.cs\par
\par
\tab Added in 1.1, this GUI allows for the creation of "Tile Templates" using modular / tileable sprites.\par
\tab Templates created using this system should be saved into the "Resources" folder for runtime access.\par
\tab The GUI features a way to load alternate tile sets into the editor. Templates created using alternate tilesets must \par
\tab be loaded with a shader that also uses this same tileset otherwise the wrong sprites will be used to draw the template.\par
\par
\tab Templates are "Stamped" on to tile map data by the static manager class either fully randomly or according to rules.\par
\tab Currently, the rules in place are that the template must be fuly contained within the data,\par
\tab that the area occupied by the template on the current background layer data is grass and\par
\tab that the area occupied by the template on the current non background layers data is Transparent.\par
\par
\tab This is for the demo which uses house templates. Placing them fully on grass keeps the original terrain shape\par
\tab while making sure top layers are empty prevents houses from being placed on top of each others.\par
\tab\par
- [UPDATED] FastMapShaderIsometric.shader, IsometricMapManager.cs & IsometricInteraction.cs\par
\par
\tab Added in 1.2, the Isometric Support scripts allow for isometric rendering of large maps at similar performance to the square grids.\par
\par
\tab Please note that despite how it may seem this system contains quite a few differences compared to a regular isometric tile map : \par
\tab\par
\tab 1 - General rendering effect \par
\par
\tab\tab In shader, the isometric effect is accomplished using two rectangular grids, one of which is offset to create interlaced grids.\par
\tab\tab Perfectly made isometric sprites for this setup are essentially twice as large as they are tall and follow one of the included models ( 16x32 to 256x128 ).\par
\tab\tab Instructions are provided to help you create a model of custom size that still follow the requirements of the isometric rendering shader.\par
\tab\tab Isometric sprites made according to these requirements will work out of the box without any visible gaps. Some sprites may need padding or other adjustments.\par
\par
\par
\tab 2 - Coordinate Space / Map Data Handling\par
\par
\tab\tab Coordinate space in the map containing array is still square, however two grids are interlaced : one grid contains even coords while the other has odd coords.\par
\tab\tab In other words, the grid coordinates Y axis is still vertical and the X axis is still horizontal relative to the camera.\par
\par
\tab\tab Helper methods are included to convert back and forth between array indices and easy to use regular isometric coordinates.\par
\tab\tab The current regular isometric coordinate style included with this method has the X axis going towards the bottom or top RIGHT while Y goes towards the bottom or top LEFT.\par
\tab\tab Direct neighbors in +-X or +-Y are therefore diagonal, as if a square grid had been rotated. \par
\tab\tab Unlike the array / data set indices, this system is much easier to use with game logic, map generation, etc.\par
\par
\tab\tab To preview the effects of the "regular" isometric coordinates, use the "Classic Isometric Rendering" toggle of the IsometricMapManager script.\par
\tab\tab This toggle will use the converted coordinates to cap the available map space using bounds that give it a classical isometric map look.\par
\tab\tab You can also use the "Debug Selected Coordinates" toggle alongside the "Coordinate Debug Style" selector to show selected tile coordinates in console.\par
\tab\tab\par
\par
\tab 3 - Isometric Depth / Fake 3D Effect\par
\par
\tab\tab The fake 3D effect is by far the biggest difference between a regular isometric tile map renderer and this shader.\par
\par
\tab\tab In order to simulate isometric depth on a single quad, some trickery is required when it comes to tile type sampling.\par
\tab\tab Unlike a square grid, a single cell on the tile map can sometimes contain multiple different tile types that need to be rendered.\par
\tab\tab Therefore, the shader may require multiple tile map data texture samples per pass depending on the sprites being used : \par
\par
\tab\tab A - Sprites with 0 "Isometric Height" can be rendered using a single sample per isometric cell on the background layer. \par
\tab\tab B - Sprites with > 0 Isometric Height taking the full size of a cell on the front layer can fully obstruct sprites behind them, reducing samples.\par
\tab\tab C - Sprites with > 0 Isometric Height that either do not take the full size of a cell or contain transparency on the front layer do not reduce samples.\par
\par
\tab\tab Also worthy of consideration is the fact that tall isometric sprites often reside on the middle point of the two interlaced grids.\par
\tab\tab This behavior, due to the isometric nature of the rendering, often causes sprites that can fully obstruct cells (B) to only obstruct half a cell.\par
\tab\tab Therefore, even in a best case scenario, multiple texture samplings will ultimately be required in order to simulate 3D depth on a 2D quad.\par
\par
\tab\tab For this, the IsometricMapManager.cs script currently uses 4 tile map data arrays labeled A through D. \par
\tab\tab When adding a sprite to the map, calculations relative to sprite origin height and potential cell osbtructions are performed.\par
\tab\tab This is to make sure tall objects that are "lower" have their sprites in front of anything that is "higher" isometrically.\par
\tab\tab It also ensures that any sprite that would be fully obstructed by something already on the tile map is simply ignored.\par
\tab\par
\tab\tab Depending on your setup, if you experience issues with missing object pieces, it is likely that you need to add more data arrays / samples.\par
\tab\tab Due to the nature of isometric rendering shader it is currently impossible to avoid this need for more tile type slots as taller objects are used.\par
\par
\par
\tab Here is a quick overview of the available parameters for the IsometricMapManager script. Sprite Width and Sprite Height are self explanatory and represent sprite sizes.\par
\tab The Map Width and Height values are also straightforward, however it is recommended to have the map height be two times the width in order for the quad to be filled up.\par
\tab This is simply due to the fact that isometric sprites are usually twice as wide as they are tall. A square sized map would not completely fill a square rendering area.\par
\tab Seed, Seedoffset and Noiseoffset values are used to tweak map generation. Offset values are changed when a new map is generated using the 'G' key.\par
\tab The TileTypeLibraryPath field is used to point to a tile type library file contained within the resources folder. This can be used to quickly test different spritesets.\par
\tab The TopLayer object link is used to link to an object using the ShaderLink.cs script. The TopLayer will handle the rendering of "layered" or "tall" isometric objects.\par
\tab Finally, the remaining toggles are used for isometric coordinate space debugging. They are explained in second point of the above explanation of isometric shader specs.\par
\par
\tab Next we have the Isometric Interaction script, which works similarly to the regular Tile Map Interaction script. It most importantly provides the mouse interaction feature.\par
\tab By default the SelectTile() function will use data set coordinates, however it is quite simple to convert the resulting value stored in selectedPoint to regular iso coords.\par
\tab Although currently missing, collision detection and live edits will most likely be implemented in a future version among other currently missing features.\par
\par
\tab Tile Type Management works in a similar manner to the regular square tile map renderer. Tile Types can be set using the manager GUI and initialized as consts in TileType.cs\par
\tab The major difference comes when using "tall" isometric sprites which require usage of more than 1 tile types to be rendered. Those types are managed automatically. More on this below.\par
\par
\tab Since version 1.3 a new Isometric Demo Scene has been added. The new demo features a new tileset and a GUI for edit baking. It also shows off a few of the features added in this version : \par
\par
\tab\tab - GPU Texture Copy Based Edit Baking, which allows for lighting fast edit baking.\par
\tab\tab - Map File Saving And Loading with basic Compression\par
\tab\tab - Nvidia Compatibility Mode\par
\par
\tab GPU Texture Copy Edits work using a small Edit Buffer texture. The size of this edit buffer can be tweaked. See "Edit Buffer Width" and "Edit Buffer Height" on the Isometric Map Manager.\par
\tab Smaller sizes have lower impact on FPS but are not well suited for large area edits like wide tile radius explosions. Large sizes may drop the FPS below acceptable levels on slower hardware.\par
\tab For general usage, a buffer size of 8x8 to 32x32 should not have an large impact on FPS. This allows for constant edits baking at a smooth framerate.\par
\par
\tab Map File Saving and Loading works as you would expect. The "Map Path" field on the isometric map manager controls the path to use as save destination or load origin.\par
\tab The "Load Map On Startup" toggle will turn on map loading, which replaces the random map generation function. To save a generated map while not in load mode, press the 'S' key.\par
\tab The "Compressed Data" toggle will switch between raw and compressed map file formats. Compression is basic RLE of repeating tile types. Drastically reduces file size with classic iso rendering.\par
\tab\par
\tab Nvidia Compatibility Mode is a workaround for a bug occuring on Nvidia hardware causing corruption of tile map data sampling coordinates. \par
\tab This results in corrupted visuals, tiles showing wrong types as well as failure of the edit buffer to work properly.\par
\tab To fix this issue, toggle on compatibility mode and SET THE MAP SIZE PARAMETERS TO POWER OF TWO VALUES. This last part is important.\par
\tab Classic isometric rendering typically uses a tile map width of (1/2 height value + 4) in order to give a square play area. This makes the width non power of two.\par
\tab Compatibility modes fixes coordinate converts in order to work with power of two width values of (1/2 height value).\par
\par
- IsometricTileSplitter.cs & IsometricTileSplitterGUI.cs\par
\par
\tab Since isometric objects often reside on multiple grid squares and since the shader doesn't allow overflowing sprites, objects must be split into parts that fit those cells.\par
\tab The Isometric Tile Splitter GUI found under "Window > Tile Map Accelerator" allows users to split isometric objects into parts fitting the input sizes and selected model file.\par
\par
\tab Before the GUI can be used, your objects will require some preparation : \par
\par
\tab\tab The folder "Resources/IsometricHelpers/" contains images of various sized splitting models used to correctly align objects for splitting.\par
\tab\tab By placing the bottom / origin of the object on the bottom (white colored) isometric cell of a model, the object will be correctly aligned. \par
\tab\tab With objects that require more vertical space, make sure the pattern is topped with a full center cell ( directly above the origin tile ) and not a corner cell.\par
\tab\tab After correctly placing the object, remove the helper model from the image and save it as PNG with transparent background. \par
\tab\tab Do not crop the empty parts of the image. After importing into your project, make sure import settings are correct and allow read & write.\par
\par
\tab Next, here is a quick usage guide for the GUI :\par
\par
\tab\tab 1 - Set the Tile Width and Height values. This is the size of each cell in your isometric grid, not the size of the whole object.\par
\tab\tab 2 - Set the "Isometric Layer Height". Ground level sprites have 0 layer height and require no splitting. An isometric cube has a layer height of 1.\par
\tab\tab 3 - Open one of the included tile template files stored inside "Resources/IsometricHelpers/TileTemplates". Pick the template size matching your sprite size.\par
\tab\tab 4 - Open the isometric object sprite you have previously prepared using the splitter models.\par
\tab\tab 5 - Hit "Save to Folder..." and select a folder into which to create the various parts of your isometric object. Set correct import settings on the created images.\par
\par
\tab Now that you have an isometric object correctly split, it is time to allow it to be used with the generator : \par
\par
\tab\tab 1 - Create a new Tile Type slot in your type library using the Tile Type Manager GUI. You can give it a custom name.\par
\tab\tab 2 - Under "Resource Folder Sprite Path" point to the root of the folder containing your sprite parts. IE : "IsometricTiles/BuildingParts/"\par
\tab\tab 3 - Set the "Iso Height" parameter. It is essentially the same value used as "Isometric Layer Height" in the splitter GUI.\par
\tab\tab 4 - Create a new constant uint reflecting the value of the created type inside the file TileType.cs to have a script reference to the new type.\par
\tab\tab\par
\tab You can now access an instance of the IsoTypes class representing your isometric object through the IsometricObjectLibrary dictionary. \par
\tab Dictionary access key is the tile type, so in order to refer to a particular object use "IsometricObjectLibrary[TileType.MY_TILE_TYPE]"\par
\tab See line 398 of the IsometricMapManager.cs script for a deeper usage example, using the AddIsometricObject() function to add buildings and trees on the map.\par
\tab\par
\tab For further customization of the splitting process or for creation of custom tile templates or tall object alignment models, see the "Resources/IsometricHelpers" folder.\par
\tab In particular, the "TemplateCreationTutorial" subfolder contains images showing guidelines on how to create "perfect" isometric tile templates.\par
\tab The core logic behind the process is creating an image that is twice as large as it is tall. Split a quarter portion in half diagonally using black and white.\par
\tab White color should be used to represent the rendering area of the isometric cell. Finish by mirroring the portion horizontally and vertically to create the template.\par
\tab An image editor with live symmetry on both axes would work very well for this process, but the mirroring can be done through copy/paste on most image editors.\par
\par
# General Usage Tips\par
\par
- Creating Tile Maps\par
\par
\tab This asset is not designed to be used as a tile map creation tool. This asset is first and foremost a tile map renderer, with added utilities.\par
\tab Therefore, it is perfectly suited for procedurally generated content. Simply send your procedurally generated data to the TileMapManager.cs script.\par
\tab For premade maps, it is also very simple to send the data array to the map manager script. \par
\tab Using native Tilemaps, the function Tilemap.GetTile() or Tilemap.GetTilesBlock() can be used to gather or create the data array.\par
\par
\tab In the end, the asset will attempt to read UNSIGNED INTEGER values from the array. The values are then interpreted as TileTypes.\par
\par
\par
- [UPDATED] Changing Tile Map Sizes\par
\par
\tab The demo scene's player controller size and camera focus parameters are set to work by default on a 2048x2048 tile map mesh.\par
\tab The XY size of the mesh gameobject in world units is 100x100. This value allows for reasonably world size of tile colliders.\par
\tab Sizes too small for colliders may result in odd behavior, such as colliders being bigger than they appear.\par
\par
\tab To quickly change the size of the demo scene tile map while keeping colliders intact, multiply the Tile Map Size and the scale of the mesh by a certain value.\par
\tab To get a tile map of 4096x4096, the mesh object size will be 200x200. For 8192x8192 mesh size is 400x400. \par
\tab\par
\tab Colliders will still work even if mesh size is changed to other values, as long as each game world tile is big enough. \par
\tab However, the player controller might become too small or too big, will move too slow or too fast. The camera focus zoom value will also be wrong.\par
\tab Active Layer Tiles will also become too small or too big. As will any other gameobject and anything not rendered on the mesh. \par
\tab All of these things can be fixed to work for your custom mesh object / tile map size ratio if you wish it.\par
\tab\par
\tab All in all, the ratio of Tile Map Size to Mesh Object Size is important to keep in mind, \par
\tab as it is responsible for the game world size of a single tile on your map rendering mesh. \par
\par
\tab Since version 1.3, a special NVidia compatibility isometric demo scene has been created which works around a hardware specific problem with isometric tile maps.\par
\tab This compatibility mode require the use of POWER OF TWO map size values, unlike regular isometric tile maps with the intent of being rendered using "Classic" isometric view.\par
\tab The general rule for Isometric Rendering is that map width must be 4 units wider than half the map height. If height is 8192, width should be 4100 ( 4096 + 4 ).\par
\tab This is to make sure the isometric looking play area is of a "square" size. In the case of 8192x4100 this creates an isometric area of 2048x2048.\par
\tab On Nvidia compatibility mode, the width should just be half the height, without the added 4 units. If height is 8192, width should be 4096. \par
\tab Power of two values MUST be used in order for the tile map to properly render on NVidia. This is due to a bug that has been reported to Unity.\par
\tab The only downside, beside the tile map being forced to use POWER OF TWO values for size, is that the "classic" isometric area created is not square.\par
\tab\par
- [OUTDATED] Getting Best Performance For Live Edits \par
\par
\tab THIS TIP IS OUTDATED SINCE VERSION 1.3 WHICH ALLOWS FOR FAST GPU TEXTURE COPY EDITS. CHECK OUT THE NEW V2 ISOMETRIC DEMO SCENE TO SEE THIS IN ACTION.\par
\par
\tab Since this tile map renderer relies on a shader, it makes use of the SetTexture2D() function to send the tile map to this shader.\par
\tab Unfortunately, this function is the performance bottleneck of this asset. Large texture maps can take a few seconds to send to the shader.\par
\tab Also, it is not possible to only send parts of a texture. The whole texture, or the whole tile map, must be send over at once.\par
\par
\tab Using the ActiveLayerManager.cs script, this asset can still allow for smooth "edits" of the tile map, which is actually done using basic\par
\tab sprite objects being layered on top of the tile map. Those edits can then be "Baked" to the shader tile map by using SetTexture2D().\par
\par
\tab Therefore, if you intend on using this asset for a game in which constant edits are a key feature, the main options are as follows.\par
\tab\par
\tab\tab 1. Use a smaller map size. Map Sizes of 128 to 512 should not impact FPS in a major way if baking happens at a reasonable pace, say every second.\par
\tab\tab 2. Bake the tile map less often. The game engine can handle a lot of live edit tiles before baking delivers a performance gain.\par
\tab\tab 3. Tile Map Chunking. Splitting the tile map and rendering it on multiple meshes allows partial map baking. Added in 1.1 ( see AutoChunkManager.cs )\par
\tab\tab 4. Shader Based Map Chunking. Edit the shader to merge X chunks into a full map. Split tile map into X chunks. Only SetTexture2D() the current chunk. May be added in a future version.\par
\par
\tab Option 3 and 4 require the most general programming knowledge. Option 4 requires shader programming knowledge.\par
\par
- Graphic Settings & Potential Texture Issues\par
\par
\tab To avoid graphical issues with sprites and the autotiling utility, the recommended image format is PNG RGBA32.\par
\tab Make sure "Read & Write" is enabled. Use "Point" filtering and "Clamp" wrap mode. Disable "Generate Mipmaps".\par
\tab Since we are using small textures, it is also recommended to use RGBA32 ( Uncompressed ) "Format" to maintain pixel art quality.\par
\par
\tab A graphical setting known to cause issues is "Anisotropic Textures". It is set to be always on for higher tier quality settings.\par
\tab Make sure Anisotropic Textures are set to "Per Texture" on all graphic presets to make sure tile maps are rendered properly.\par
\par
- Standalone Build & Platform Specific Issues\par
\par
\tab If you are experiencing issues in standalone build, the first step is to make sure the shaders are added in your "Always Included Shaders" list in Graphics settings.\par
\tab This is the most likely culprit for the issue of having pink materials rather than the tile map being rendered.\par
\par
\tab Some platforms may have special limitations. As stated in the asset description, the shader relies on Texture2DArrays which are not supported on all platforms.\par
\tab WebGL does not allow Graphics.CopyTexture based edit baking and also has a map size limit due to the maximum amount of RAM allocated.\par
\tab\par
\tab Some hardware may experience issues. One of the known hardware specific issue is a Nvidia GPU limitation forcing the use of POWER OF TWO map sizes for isometric rendering.\par
\tab This Nvidia related issue has been reported to Unity, but for the moment a "compatibility mode" has been added to the asset. See the "isometricdemov2 NVIDIA" demo scene.\par
\tab  \par
\tab If you experience any platform specific issue, make sure to include as many details as possible about your setup in your bug report.\par
\par
# Final Word and Support\par
\par
Thank you for buying Tile Map Accelerator! This asset is still in development and will be continually improved based on user feedback.\par
\par
If you have any trouble, questions, bug reports, feedback or feature requests, please use the following email address.\par
\par
r3eckon@gmail.com\par
\par
\par
\par
}
 