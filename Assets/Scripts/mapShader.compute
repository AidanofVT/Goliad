// Each #kernel tells which function to compile; you can have many kernels


// RWStructuredBuffer<int> input;
// RWStructuredBuffer<int> newImage;
RWStructuredBuffer<float> bugger;
RWStructuredBuffer<float> imageLibrary;
RWStructuredBuffer<int> world;
RWStructuredBuffer<float2> cameraDimensions;
RWStructuredBuffer<float2> hereNow;
RWStructuredBuffer<float2> scale;
RWStructuredBuffer<float> output;

#pragma kernel action
[numthreads(1,1,1)]
void action (uint3 group : SV_GroupID, uint3 thread : SV_GroupThreadID) {
    uint totalWidth = cameraDimensions[0].x;
    float halfWidth = totalWidth / 2;
    uint totalHeight = cameraDimensions[0].y;
    float halfHeight = totalHeight / 2;
    uint offset, nevermind;
    world.GetDimensions(offset, nevermind);
    offset = sqrt(offset) / 2;
    uint sectorLength = totalWidth / 8; //THE DIVISOR CHANGES IF THE THREAD COUNT IS CHANGED
    uint sectorHeight = totalHeight / 8; //THE DIVISOR CHANGES IF THE THREAD COUNT IS CHANGED
    uint xStart = group.x * sectorLength;
    uint yStart = group.y * sectorHeight;
    // uint members, stride;
    // imageLibrary.GetDimensions(members, stride);
    // bugger[0] = scale[0].x;
    // bugger[1] = scale[0].y;
    for (int i = 0; i < 64; ++i) {
        bugger[i] = world[i];
    }
    int k = 0;
    for (uint i = 0; i < sectorHeight; ++i) {
        for (uint j = 0; j < sectorLength; ++j) {
            float worldX = hereNow[0].x + ((float)(xStart - halfWidth) + (float) j) * scale[0].x / halfWidth;
            float worldY = hereNow[0].y + ((float)(yStart - halfHeight) + (float) i) * scale[0].y / halfHeight;
            int xInSquare = floor(worldX);
            int yInSquare = floor(worldY);
            int tileType = world[(xInSquare + offset) * offset * 2 + (yInSquare + offset)];
            int2 fromPixel = int2((float)(worldX - xInSquare) * 128, (float)(worldY - yInSquare) * 128);
            int2 toPixel = int2 (j + xStart, i + yStart);
            output[cameraDimensions[0].x * toPixel.y + toPixel.x] = imageLibrary.Load(16384 * tileType + 128 * fromPixel.y + fromPixel.x);
            // if (group.x == 1 && group.y == 0) {
            //     bugger[k] = toPixel.x;
            //     ++k;
            // }
        }
    }
    //bugger[group.x * 2 + group.y] = xStart;
    // for (i = 0; i < 4; ++i ) {
    //     bugger[i] = world[i];
    // }
}
